# S-AES
## 测试结果（共五关）
### 第一关：基本测试
基本测试格式如下：

明文：16位二进制数

密文：16位二进制数

密钥：16位二进制数

*** 
标准加密

按照实验基本要求的输入格式，输入明文和密钥

<img width="334" alt="图片1" src="https://github.com/user-attachments/assets/b9ca7f7a-2f1e-43bc-ba20-f95a67d925a0">


测试结果

<img width="331" alt="图片2" src="https://github.com/user-attachments/assets/e1fdc3e4-877a-415d-9bb3-745a52c87777">

***
标准解密

按照实验基本要求的输入格式，将加密得到的密文和加密使用的密钥作为输入，看能否解密得到被加密的明文

<img width="333" alt="图片3" src="https://github.com/user-attachments/assets/4737edfc-4e85-4e18-80dd-a79e81fefd42">

**因此，在基本加解密测试中，加密所用的密钥和明文能够与解密所用密钥与密文对应，说明基本加解密通过测试。**
	| 明文 | 密钥 |	密文 |
 | 16位二进制加密 |	1010101010101010 | 	0101010101010101 |	0110010001101011 | 
	| 密文 |	密钥 |	 明文 |
 | 16位二进制解密 |	| 0110010001101011 |	0101010101010101 |	1010101010101010 |

第二关：交叉测试
考虑到是"算法标准"，所有人在编写程序的时候需要使用相同算法流程和转换单元(替换盒、列混淆矩阵等)，以保证算法和程序在异构的系统或平台上都可以正常运行。 本项目已经与黎雷组的同学进行了二进制的加密交叉测试，得出结果如下
黎雷组

我们组

因此，使用相同的密钥和明文能够得出相同的加密结果，加密通过测试。
同时，我们小组也与其他组进行了解密测试。
以下为其他小组的测试结果

我们组

因此，使用相同的密钥和密文能够得出相同的解密结果，解密通过测试。
第三关：扩展功能
考虑到向实用性扩展，加密算法的数据输入可以是ASII编码字符串(分组为2 Bytes)，对应地输出也可以是ACII字符串(很可能是乱码)。
扩展功能测试输入格式如下：
明文：任意ASCII编码字符串
密钥：16bit二进制数
注意:密钥应该为16bits 加密后极大可能出现乱码
以下是加密测试

以下是解密测试

第四关：多重加密
1.双重加解密的实现
双重加密
在完成基础的加解密功能之外，还完成了双重加密功能，使用32位的密钥，将密钥分为key1和key2，分别对两个密钥进行密钥扩展，先使用key1加密明文，再使用key2加密密文，得到最终的加密结果 对此我们使用了下面的测试
测试格式如下：
明文：16位十六进制数
密钥：32位十六进制数
测试结果如下：

这里我们按照双重加密的步骤使用AES分别进行两次加密，如果得到相同结果，则测试成功。
分别进行两次加密结果如下



由于进行双重加密和分别进行两次加密得到了相同的密文，因此测试成功。


双重解密：
按照实验基本要求的输入格式，将加密得到的密文和加密使用的密钥作为输入，看能否解密得到被加密的明文
测试格式如下：
密文：16位十六进制数
密钥：32位十六进制数
测试结果如下：

因此，在双重解密测试中，加密所用的密钥和明文能够与解密所用密钥与密文对应，说明双重解密通过测试。
	明文	密钥	密文
16位十六进制加密	0x1243	0x98765432	0x20c4
	密文	密钥	明文
16位十六进制解密	0x20c4	0x98765432	0x1243
2.中间相遇攻击
我们组使用了同一组密钥对应的三组明密文对来进行中间相遇攻击，每次计算出一组明密文对满足的所有密钥对， 然后将三组得到的所有密钥对进行比较来得到唯一的密钥。
测试方法如下：
将密钥设置为key1=0xacaf，key2=0x3c11，使用该密钥进行双重加密得到2组，3组..明密文对，直到中间相遇攻击能够找到唯一一对共同密钥。
使用设置的密钥进行双重加密的结果：
密钥	明文	密文
K1=0xacaf
K2=0x3c11	0x1234	0x4321
	0x1233	0xb32f
	0x1235	0xc324
使用中间相遇攻击的测试结果：



因此，使用中间相遇攻击能够找到正确的共同密钥，测试成功。
3.三重加解密的实现
与双重加解密类似：这里我们按照32bits密钥key（k1+k2）的模式进行三重加密，key=key1+key2+key3(key1)，依次使用key1、key2、key3对明文、中间态、第二次加密得到的中间态进行加密，得到密文，解密过程则相反
对此我们使用了下面的测试来进行验证：
三重加密：
测试结果如下

这里我们按照三重加密的步骤使用AES分别进行三次加密，如果得到相同结果，则测试成功。
分别进行三次加密结果如下




由于进行三重加密和分别进行三次加密得到了相同的密文，因此测试成功。


三重解密：
按照实验基本要求的输入格式，将加密得到的密文和加密使用的密钥作为输入，看能否解密得到被加密的明文
测试结果如下


因此，在三重解密测试中，加密所用的密钥和明文能够与解密所用密钥与密文对应，说明三重解密通过测试。

第五关：工作模式
基于S-AES算法，还可使用密码分组链(CBC)模式对较长的明文消息进行加密。
1.选择一个16位的初始向量（IV）
2.将较长的明文消息分成固定大小的块（16位），然后使用S-AES算法来依次加密每个块。
3.对于第一个块，将它与初始向量进行XOR操作，然后使用S-AES进行加密。加密后的结果成为下一个块的初始向量。
4.对于后续的块，将明文块与前一个加密块进行XOR操作，然后使用S-AES进行加密。这个过程会一直持续，直到整个消息被加密。
5.发送加密后的消息以及最后一个加密块给接收方。
6.接收方知道初始向量，它可以根据相同的步骤解密消息，将每个块解密并将结果与前一个块的密文进行XOR操作。
下面是测试案例


在本次测试中，我们通过将密文的第一个字节异或1完成对密文的篡改，然后进行解密，对比篡改密文前后的解密结果。通过测试案例发现，对密文第一个字节进行篡改后，解密所得16进制明文的前三位受到影响，后五位不变。
因此，我们组推测得以二进制16bits为一个明文块和密文块，如果某一个密文块被篡改，则与其对应的明文块会受到影响，其他明文块则不受影响，不存在连锁反应。













